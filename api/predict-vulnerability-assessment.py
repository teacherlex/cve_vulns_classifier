from keras.models import load_model
from keras.preprocessing.sequence import pad_sequences
import numpy as np
import keras
import tensorflow as tf

import os	
import flask
from flask import send_file
import io
import json

app = flask.Flask(__name__)

model = None
wordsByIndex = None
graph = None

pathModel="/predict-deploy/somemodel3.h5"
#pathModel="somemodel3.h5"
pathVocabularyIndexes="/predict-deploy/wordsByIndex.json"
#pathVocabularyIndexes="wordsByIndex.json"

def loadModel():    
    global model
    keras.backend.clear_session()
    model = load_model(pathModel)
    #model._make_predict_function()
	
    # global graph
    # graph = tf.get_default_graph()

def loadWordsByIndex():    
    global wordsByIndex
    with open(pathVocabularyIndexes, 'r') as file:
        wordsByIndex = json.load(file)
		
def predictByMessage(message):
    wordsIndexes = [[wordsByIndex[word] for word in message.split() if word in wordsByIndex.keys()]]
    paddedIndexes = pad_sequences(np.array(wordsIndexes),1000)
    # with graph.as_default():
    predicted = model.predict(paddedIndexes).tolist()
    return predicted	

@app.route("/binaryClassification", methods=["GET", "POST"])
def predict():
    data = {"success": False}
    data["predictions"] = []

    if flask.request.method == "GET":
        if flask.request.args.get("vulnerabilityDescription"):
            message = flask.request.args["vulnerabilityDescription"]
            predicted = predictByMessage(message)
            data["predictions"] = predicted
            data["success"] = True
       
    if flask.request.method == "POST":
        if flask.request.data:
            jdata = flask.request.get_json()
            predictions = {}
            for message in jdata["vulnerabilityDescriptions"]: 
                predicted = predictByMessage(message)
                predictions[message] = predicted
			
            data["predictions"] = predictions
            data["success"] = True
			
    return flask.jsonify(data)

@app.route("/predictByManyTexts", methods=["POST"])
def predictByManyTexts():
    data = {"success": False}
    data["predictions"] = []
    #if flask.request.method == "POST":
    #    if flask.request.args.get("vulnerabilityDescription"):
         
    return flask.jsonify(data)

@app.route("/modelSummary", methods=["GET"])
def getModelSummary():
    summary = model.to_json()
    return flask.jsonify(summary)

@app.route("/model", methods=["GET","POST"])
def manageModel():
    if flask.request.method == 'POST':
        file = flask.request.files['file']
        print(file)
        if file:
            file.save(pathModel)
            loadModel()
            return json.dumps({'success':True}), 200, {'ContentType':'application/json'}
	
    if flask.request.method == 'GET':
        return send_file(pathModel)
    
    return json.dumps({'success':False}), 401, {'ContentType':'application/json'}	

@app.route("/wordsByIndexes", methods=["GET", "POST"])
def manageWordsByIndexes():
    if flask.request.method == 'POST':
        file = flask.request.files['file']
        print(file)
        if file:
            file.save(pathVocabularyIndexes)
            loadWordsByIndex()
            return json.dumps({'success':True}), 200, {'ContentType':'application/json'}
	
    if flask.request.method == 'GET':
        return flask.jsonify(wordsByIndex)
    
    return json.dumps({'success':False}), 401, {'ContentType':'application/json'}	

if __name__ == "__main__":
    print(("* Loading Keras model and Flask starting server..."
        "please wait until server has fully started"))
    loadModel()
    loadWordsByIndex()
    app.run(host='0.0.0.0', port=5010, threaded=False)
